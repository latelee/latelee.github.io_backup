---
layout: post
title: 
category : linux系统
tags : [Makefile]
---
背景：
在大型工程中整合Makefile。
<!- more -->

方法1：
将所有涉及到的文件编译为.o，然后进行链接。
优点：
无须使用静态库。直接使用一个Makefile可编译所有目录、所有文件。
缺点：
要一一指定哪些文件是需要的，哪些是不需要的。
在大型项目中，这点无法做到（即使做到，维护很麻烦。）

方法2：
各子模块编译为静态库，然后主程序链接。

测试示例：
线程库+main文件。但main文件只调用printf，不调用线程库。使用-g选项编译。

添加thread，生成文件大小：
76088
如果不编译thread，大小：
9696

使用静态库：
ar -cr -o thread.a *.o

链接静态库：
g++ -g main.o thread.a  -o b.out
得到文件大小：
9696

查看a.out、b.out，发现a.out带有thread库函数。


为何不用动态库？在嵌入式上，难维护。在固件升级时会涉及很多的分区（如rootfs、app分区），类似，嵌入式的驱动文件也不建议使用.ko，而是整合到内核中。

小结：
针对大型代码工程，建议使用静态库方式链接。

以上仅对本次测试结果负责。

