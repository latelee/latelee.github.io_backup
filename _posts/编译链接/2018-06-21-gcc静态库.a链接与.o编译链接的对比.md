---
layout: post
title: 
category : 编译链接
tags : [Makefile]
---
## 背景：
在大型工程中整合Makefile。纠结于生成二进制可执行文件过程使用.o链接还是用静态库链接，于是单独对此进行实验。
<!-- more -->

编译链接过程，有2个方式生成二进制可执行文件。

## 方法1
将所有涉及到的文件编译为.o，然后进行链接。

优点：

无须使用静态库。直接使用一个Makefile可编译所有目录、所有文件。

缺点：

要一一指定哪些文件是需要的，哪些是不需要的。在大型项目中，这点无法做到（即使做到，维护很麻烦。）

## 方法2
各子模块编译为静态库，然后主程序链接。

## 测试示例

pthread线程库+main文件。但main文件只调用printf，不调用线程库任何函数。

使用方法1，添加pthread线程库，生成文件大小：76088。

如果使用方法2，即使用静态库方式链接pthread，生成文件大小：9696。过程如下：

使用静态库：
```
ar -cr -o thread.a *.o
```
链接静态库：
```
g++ -g main.o thread.a  -o b.out
```

查看a.out、b.out，发现a.out带有pthread库函数。但b.out没有。在示例工程中，是没有线程库函数的，因此，a.out和b.out的执行结果上是一致的，但b.out的体积相对来说小很多。

为减小体积，一般会使用动态库，但不建议使用动态库，为何？在嵌入式上，比较难维护。因为在固件升级时会涉及很多的分区（如rootfs、app分区），过程较麻烦，不再描述。类似地，嵌入式的驱动文件也不建议使用.ko，而是整合到内核中。

## 小结：
针对大型代码工程，建议使用静态库方式链接。

以上仅对本次测试结果负责。
